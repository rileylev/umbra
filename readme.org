#+TITLE: Readme
Macro utilities for shadowing with lexical scope

Accidental shadowing can cause trouble, especially because of how it interacts with other C++ features. But intentional shadowing is useful; it can block or modify access to variables. I often want to express a variable "becomes" const---nothing beyond this point is allowed to modify it. For example, you can use shadowing to assert a loop's index variable is never modified in its body:

#+BEGIN_SRC cpp
    for(int i = 0; i < len, ++i)
      FREEZE(i) {
        if(pred(i))
          arr[i]++;
      }
#+END_SRC



This library provides 4 macros:

 - ~UMBRA_SHADOW~ which disables shadowing warnings for one definition and introduces a scope:

#+BEGIN_SRC cpp
    int const x = 3;
    SHADOW(int x = 2){
      ++x;              // ok!
    }
#+END_SRC

 - ~UMBRA_POISON~, which bans variables from use in the new scope:

#+BEGIN_SRC cpp
    int x = 3;
    int y = 2;
    POISON(x,y){
      auto z = x + y; // warning/error!
    }
#+END_SRC

 - ~UMBRA_FREEZE~, which makes variables const within the new scope:

#+BEGIN_SRC cpp
    int x = 2;
    int y = 3;
    FREEZE(x,y){
      ++x, ++y;   // error
    }
#+END_SRC

 - and ~UMBRA_READIN~, which will rebind a variable to a copy if the type is easy to copy:

#+BEGIN_SRC cpp
    template<class T>
    auto example(T const& x){
      UMBRA_READIN(x){    // we want a read only variable
                          // but not necessarily a reference
      }
    }
#+END_SRC
