#+TITLE: Umbra: macros for shadowing and scope management

Shadowing variables is useful. Removing a variable from a scope can enforce desired properties of code. This example protects the loop's invariant by shadowing the loop's variable to make it ~const~ within the loop's body:
#+BEGIN_SRC cpp
for(int i = 0; i < len, ++i) {
  auto const j = i;
  {
    int i =0;
    // Now we can't change the loop index
    if(pred(j))
      arr[j]++; //error!
    ...
  }
}
#+END_SRC
or, using Umbra,
#+BEGIN_SRC cpp
for(int i = 0; i < len, ++i)
  UMBRA_FREEZE(i) {
    if(pred(i))
      arr[i]++; //error!
    ...
  }
#+END_SRC

Accidentally shadowing can be devastating, especially with RAII types:
[[https://youtu.be/lkgszkPnV8g][From curiously recurring C++ Bugs at facebook by Louis Brandy]]
#+BEGIN_SRC cpp
std::mutex mut;
void critical_section(){
  std::unique_lock(mut);
  // this defines a default-constructed lock shadowing mut
  // the author intended to lock it
  ...
}
#+END_SRC
Here the programmer meant to lock the mutex, but actually created a default-constructed lock named ~mut~. Bugs like this are hard for humans to catch, but easy for machines: ~Wshadow~ would catch it.

So turn on ~-Wshadow~ and ~-Werror~. When you truly do want to shadow one variable, turn off shadow warnings locally. Enter ~UMBRA_IGNORE_SHADOW~:
#+BEGIN_SRC cpp
int x = 1;
{
  std::string x; // ERROR!
  UMBRA_IGNORE_SHADOW(
    char x = '\0'; // OK!
  )
}
#+END_SRC
or ~UMBRA_SHADWO~ for a little more syntactic sugar:
#+BEGIN_SRC cpp
int x = 1;
{
  UMBRA_SHADOW(char x = '\0'){ // Ok!
    ...
  }
}
#+END_SRC

* Why use a library for shadowing?
Because accidental shadowing interacts poorly with quirks of C++, strict shadow warnings can prevent lots of problems, including surprising data races like this:
#+BEGIN_SRC cpp
std::mutex mut;
void critical_section(){
    std::unique_lock(mut);
    // this defines a default-constructed lock shadowing mut
    // the author intended to lock it
    ...
}
#+END_SRC
[[https://youtu.be/lkgszkPnV8g][From curiously recurring C++ Bugs at facebook by Louis Brandy]]

So to intentionally shadow, you need to turn off shadow warnings locally. Umbra provides this with ~UMBRA_IGNORE_SHADOW(...)~, which wraps its argument with the ~#pragma~ s to turn shadow warnings off and then back on.

Umbra wraps up some common shadowing patterns into macros, which state your intent and handle the tricky bits.

Compare the wrong but tempting implementation of ~UMBRA_FREEZE~ by hand
#+BEGIN_SRC cpp
for(int i = 0; i < len, ++i) {
  {
    auto const& i = i; // ERROR: variable with deduced type cannot appear
                       // in its own initializer
    if(pred(i)) arr[i]++;
  }
}
#+END_SRC
 The correct two-step version
#+BEGIN_SRC cpp
for(int i = 0; i < len, ++i) {
  {
    auto const& i_ = i;
    auto const& i  = i_; // Okay!
    if(pred(i)) arr[i]++;
  }
}
#+END_SRC
And using umbra:
#+BEGIN_SRC cpp
for(int i = 0; i < len, ++i) {
  UMBRA_FREEZE(i) {
    if(pred(i)) arr[i]++;
  }
}
#+END_SRC
